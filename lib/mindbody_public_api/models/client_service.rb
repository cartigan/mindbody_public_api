# mindbody_public_api
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

require 'date'
module MindbodyPublicApi
  # A service that is on a client's account.
  class ClientService < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # The date that this pricing option became active and could be used to pay
    # for services.
    # @return [DateTime]
    attr_accessor :active_date

    # The number of service sessions this pricing option contained when first
    # purchased.
    # @return [Integer]
    attr_accessor :count

    # When `true`, there are service sessions remaining on the pricing option
    # that can be used pay for the current session.<br />
    # When `false`, the client cannot use this pricing option to pay for other
    # services.
    # @return [TrueClass | FalseClass]
    attr_accessor :current

    # The date when the pricing option expires and can no longer be used to pay
    # for services, even if unused service sessions remain on the option;
    # expressed as UTC.
    # @return [DateTime]
    attr_accessor :expiration_date

    # The unique ID assigned to this pricing option, specific to when it was
    # purchased by the client.
    # @return [Integer]
    attr_accessor :id

    # The unique ID of this pricing option, not specific to any client's
    # purchase of it.
    # @return [Integer]
    attr_accessor :product_id

    # The name of this pricing option.
    # @return [String]
    attr_accessor :name

    # The date on which the client paid for this pricing option.
    # @return [DateTime]
    attr_accessor :payment_date

    # The date on which the client paid for this pricing option.
    # @return [Program]
    attr_accessor :program

    # The number of service sessions remaining in the pricing option that can
    # still be used.
    # @return [Integer]
    attr_accessor :remaining

    # The ID of the subscriber site associated with this pricing option.
    # @return [Integer]
    attr_accessor :site_id

    # The action taken.
    # @return [Action1Enum]
    attr_accessor :action

    # The Client ID assigned to this pricing option, specific to when it was
    # purchased by the client.
    # @return [String]
    attr_accessor :client_id

    # Identification for purchased service is returned or not.
    # @return [TrueClass | FalseClass]
    attr_accessor :returned

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['active_date'] = 'ActiveDate'
      @_hash['count'] = 'Count'
      @_hash['current'] = 'Current'
      @_hash['expiration_date'] = 'ExpirationDate'
      @_hash['id'] = 'Id'
      @_hash['product_id'] = 'ProductId'
      @_hash['name'] = 'Name'
      @_hash['payment_date'] = 'PaymentDate'
      @_hash['program'] = 'Program'
      @_hash['remaining'] = 'Remaining'
      @_hash['site_id'] = 'SiteId'
      @_hash['action'] = 'Action'
      @_hash['client_id'] = 'ClientID'
      @_hash['returned'] = 'Returned'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        active_date
        count
        current
        expiration_date
        id
        product_id
        name
        payment_date
        program
        remaining
        site_id
        action
        client_id
        returned
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(active_date = SKIP, count = SKIP, current = SKIP,
                   expiration_date = SKIP, id = SKIP, product_id = SKIP,
                   name = SKIP, payment_date = SKIP, program = SKIP,
                   remaining = SKIP, site_id = SKIP, action = SKIP,
                   client_id = SKIP, returned = SKIP)
      @active_date = active_date unless active_date == SKIP
      @count = count unless count == SKIP
      @current = current unless current == SKIP
      @expiration_date = expiration_date unless expiration_date == SKIP
      @id = id unless id == SKIP
      @product_id = product_id unless product_id == SKIP
      @name = name unless name == SKIP
      @payment_date = payment_date unless payment_date == SKIP
      @program = program unless program == SKIP
      @remaining = remaining unless remaining == SKIP
      @site_id = site_id unless site_id == SKIP
      @action = action unless action == SKIP
      @client_id = client_id unless client_id == SKIP
      @returned = returned unless returned == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      active_date = if hash.key?('ActiveDate')
                      (DateTimeHelper.from_rfc3339(hash['ActiveDate']) if hash['ActiveDate'])
                    else
                      SKIP
                    end
      count = hash.key?('Count') ? hash['Count'] : SKIP
      current = hash.key?('Current') ? hash['Current'] : SKIP
      expiration_date = if hash.key?('ExpirationDate')
                          (DateTimeHelper.from_rfc3339(hash['ExpirationDate']) if hash['ExpirationDate'])
                        else
                          SKIP
                        end
      id = hash.key?('Id') ? hash['Id'] : SKIP
      product_id = hash.key?('ProductId') ? hash['ProductId'] : SKIP
      name = hash.key?('Name') ? hash['Name'] : SKIP
      payment_date = if hash.key?('PaymentDate')
                       (DateTimeHelper.from_rfc3339(hash['PaymentDate']) if hash['PaymentDate'])
                     else
                       SKIP
                     end
      program = Program.from_hash(hash['Program']) if hash['Program']
      remaining = hash.key?('Remaining') ? hash['Remaining'] : SKIP
      site_id = hash.key?('SiteId') ? hash['SiteId'] : SKIP
      action = hash.key?('Action') ? hash['Action'] : SKIP
      client_id = hash.key?('ClientID') ? hash['ClientID'] : SKIP
      returned = hash.key?('Returned') ? hash['Returned'] : SKIP

      # Create object from extracted values.
      ClientService.new(active_date,
                        count,
                        current,
                        expiration_date,
                        id,
                        product_id,
                        name,
                        payment_date,
                        program,
                        remaining,
                        site_id,
                        action,
                        client_id,
                        returned)
    end

    def to_custom_active_date
      DateTimeHelper.to_rfc3339(active_date)
    end

    def to_custom_expiration_date
      DateTimeHelper.to_rfc3339(expiration_date)
    end

    def to_custom_payment_date
      DateTimeHelper.to_rfc3339(payment_date)
    end
  end
end
