# mindbody_public_api
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

require 'date'
module MindbodyPublicApi
  # UpdateContactLogRequest Model.
  class UpdateContactLogRequest < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # The ID of the contact log being updated.
    # @return [Integer]
    attr_accessor :id

    # When `true`, indicates that this is a test request and no data is inserted
    # into the subscriber’s database.<br />
    # When `false`, the database is updated.
    # @return [TrueClass | FalseClass]
    attr_accessor :test

    # The ID of the staff member to whom the contact log is now being assigned.
    # @return [Integer]
    attr_accessor :assigned_to_staff_id

    # The contact log’s new text.
    # @return [String]
    attr_accessor :text

    # The name of the new person to be contacted by the assigned staff member.
    # @return [String]
    attr_accessor :contact_name

    # The new date by which the assigned staff member should complete this
    # contact log.
    # @return [DateTime]
    attr_accessor :followup_by_date

    # The new method by which the client wants to be contacted.
    # @return [String]
    attr_accessor :contact_method

    # When `true`, indicates that the contact log is complete.
    # When `false`, indicates the contact log isn’t complete.
    # @return [TrueClass | FalseClass]
    attr_accessor :is_complete

    # Contains information about the comments being updated or added to the
    # contact log. Comments that have an ID of `0` are added to the contact log.
    # @return [Array[UpdateContactLogComment]]
    attr_accessor :comments

    # Contains information about the contact logs types being assigned to the
    # contact log, in addition to the contact log types that are already
    # assigned.
    # @return [Array[UpdateContactLogType]]
    attr_accessor :types

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['id'] = 'Id'
      @_hash['test'] = 'Test'
      @_hash['assigned_to_staff_id'] = 'AssignedToStaffId'
      @_hash['text'] = 'Text'
      @_hash['contact_name'] = 'ContactName'
      @_hash['followup_by_date'] = 'FollowupByDate'
      @_hash['contact_method'] = 'ContactMethod'
      @_hash['is_complete'] = 'IsComplete'
      @_hash['comments'] = 'Comments'
      @_hash['types'] = 'Types'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        id
        test
        assigned_to_staff_id
        text
        contact_name
        followup_by_date
        contact_method
        is_complete
        comments
        types
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(id = SKIP, test = SKIP, assigned_to_staff_id = SKIP,
                   text = SKIP, contact_name = SKIP, followup_by_date = SKIP,
                   contact_method = SKIP, is_complete = SKIP, comments = SKIP,
                   types = SKIP)
      @id = id unless id == SKIP
      @test = test unless test == SKIP
      @assigned_to_staff_id = assigned_to_staff_id unless assigned_to_staff_id == SKIP
      @text = text unless text == SKIP
      @contact_name = contact_name unless contact_name == SKIP
      @followup_by_date = followup_by_date unless followup_by_date == SKIP
      @contact_method = contact_method unless contact_method == SKIP
      @is_complete = is_complete unless is_complete == SKIP
      @comments = comments unless comments == SKIP
      @types = types unless types == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      id = hash.key?('Id') ? hash['Id'] : SKIP
      test = hash.key?('Test') ? hash['Test'] : SKIP
      assigned_to_staff_id =
        hash.key?('AssignedToStaffId') ? hash['AssignedToStaffId'] : SKIP
      text = hash.key?('Text') ? hash['Text'] : SKIP
      contact_name = hash.key?('ContactName') ? hash['ContactName'] : SKIP
      followup_by_date = if hash.key?('FollowupByDate')
                           (DateTimeHelper.from_rfc3339(hash['FollowupByDate']) if hash['FollowupByDate'])
                         else
                           SKIP
                         end
      contact_method = hash.key?('ContactMethod') ? hash['ContactMethod'] : SKIP
      is_complete = hash.key?('IsComplete') ? hash['IsComplete'] : SKIP
      # Parameter is an array, so we need to iterate through it
      comments = nil
      unless hash['Comments'].nil?
        comments = []
        hash['Comments'].each do |structure|
          comments << (UpdateContactLogComment.from_hash(structure) if structure)
        end
      end

      comments = SKIP unless hash.key?('Comments')
      # Parameter is an array, so we need to iterate through it
      types = nil
      unless hash['Types'].nil?
        types = []
        hash['Types'].each do |structure|
          types << (UpdateContactLogType.from_hash(structure) if structure)
        end
      end

      types = SKIP unless hash.key?('Types')

      # Create object from extracted values.
      UpdateContactLogRequest.new(id,
                                  test,
                                  assigned_to_staff_id,
                                  text,
                                  contact_name,
                                  followup_by_date,
                                  contact_method,
                                  is_complete,
                                  comments,
                                  types)
    end

    def to_custom_followup_by_date
      DateTimeHelper.to_rfc3339(followup_by_date)
    end
  end
end
