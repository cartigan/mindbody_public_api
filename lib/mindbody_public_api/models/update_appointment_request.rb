# mindbody_public_api
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

require 'date'
module MindbodyPublicApi
  # UpdateAppointmentRequest Model.
  class UpdateAppointmentRequest < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # A unique ID for the appointment.
    # @return [Integer]
    attr_accessor :appointment_id

    # The end date and time of the new appointment. 
    # <br />Default: **StartDateTime**, offset by the staff member’s default
    # appointment duration.
    # @return [DateTime]
    attr_accessor :end_date_time

    # The action taken to add this appointment. Possible values are: confirm,
    # unconfirm, arrive, unarrive, cancel, latecancel, complete.
    # @return [String]
    attr_accessor :execute

    # The client’s service provider gender preference.
    # @return [String]
    attr_accessor :gender_preference

    # Any general notes about this appointment.
    # @return [String]
    attr_accessor :notes

    # Optional external key for api partners.
    # @return [String]
    attr_accessor :partner_external_id

    # If a user has Complementary and Alternative Medicine features enabled,
    # this parameter assigns a provider ID to the appointment.
    # @return [String]
    attr_accessor :provider_id

    # A list of resource IDs to associate with the new appointment.
    # @return [Array[Integer]]
    attr_accessor :resource_ids

    # Whether to send client an email for cancellations. An email is sent only
    # if the client has an email address and automatic emails have been set up. 
    # <br />Default: **false**
    # @return [TrueClass | FalseClass]
    attr_accessor :send_email

    # The session type associated with the new appointment.
    # @return [Integer]
    attr_accessor :session_type_id

    # The ID of the staff member who is adding the new appointment.
    # @return [Integer]
    attr_accessor :staff_id

    # The start date and time of the new appointment.
    # @return [DateTime]
    attr_accessor :start_date_time

    # When `true`, appointment will be updated with a current applicable client
    # service from the clients account. 
    # <br />Default: **false**
    # @return [TrueClass | FalseClass]
    attr_accessor :apply_payment

    # When `true`, indicates that the method is to be validated, but no new
    # appointment data is added. 
    # <br />Default: **false**
    # @return [TrueClass | FalseClass]
    attr_accessor :test

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['appointment_id'] = 'AppointmentId'
      @_hash['end_date_time'] = 'EndDateTime'
      @_hash['execute'] = 'Execute'
      @_hash['gender_preference'] = 'GenderPreference'
      @_hash['notes'] = 'Notes'
      @_hash['partner_external_id'] = 'PartnerExternalId'
      @_hash['provider_id'] = 'ProviderId'
      @_hash['resource_ids'] = 'ResourceIds'
      @_hash['send_email'] = 'SendEmail'
      @_hash['session_type_id'] = 'SessionTypeId'
      @_hash['staff_id'] = 'StaffId'
      @_hash['start_date_time'] = 'StartDateTime'
      @_hash['apply_payment'] = 'ApplyPayment'
      @_hash['test'] = 'Test'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        end_date_time
        execute
        gender_preference
        notes
        partner_external_id
        provider_id
        resource_ids
        send_email
        session_type_id
        staff_id
        start_date_time
        apply_payment
        test
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(appointment_id = nil, end_date_time = SKIP, execute = SKIP,
                   gender_preference = SKIP, notes = SKIP,
                   partner_external_id = SKIP, provider_id = SKIP,
                   resource_ids = SKIP, send_email = SKIP,
                   session_type_id = SKIP, staff_id = SKIP,
                   start_date_time = SKIP, apply_payment = SKIP, test = SKIP)
      @appointment_id = appointment_id
      @end_date_time = end_date_time unless end_date_time == SKIP
      @execute = execute unless execute == SKIP
      @gender_preference = gender_preference unless gender_preference == SKIP
      @notes = notes unless notes == SKIP
      @partner_external_id = partner_external_id unless partner_external_id == SKIP
      @provider_id = provider_id unless provider_id == SKIP
      @resource_ids = resource_ids unless resource_ids == SKIP
      @send_email = send_email unless send_email == SKIP
      @session_type_id = session_type_id unless session_type_id == SKIP
      @staff_id = staff_id unless staff_id == SKIP
      @start_date_time = start_date_time unless start_date_time == SKIP
      @apply_payment = apply_payment unless apply_payment == SKIP
      @test = test unless test == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      appointment_id = hash.key?('AppointmentId') ? hash['AppointmentId'] : nil
      end_date_time = if hash.key?('EndDateTime')
                        (DateTimeHelper.from_rfc3339(hash['EndDateTime']) if hash['EndDateTime'])
                      else
                        SKIP
                      end
      execute = hash.key?('Execute') ? hash['Execute'] : SKIP
      gender_preference =
        hash.key?('GenderPreference') ? hash['GenderPreference'] : SKIP
      notes = hash.key?('Notes') ? hash['Notes'] : SKIP
      partner_external_id =
        hash.key?('PartnerExternalId') ? hash['PartnerExternalId'] : SKIP
      provider_id = hash.key?('ProviderId') ? hash['ProviderId'] : SKIP
      resource_ids = hash.key?('ResourceIds') ? hash['ResourceIds'] : SKIP
      send_email = hash.key?('SendEmail') ? hash['SendEmail'] : SKIP
      session_type_id =
        hash.key?('SessionTypeId') ? hash['SessionTypeId'] : SKIP
      staff_id = hash.key?('StaffId') ? hash['StaffId'] : SKIP
      start_date_time = if hash.key?('StartDateTime')
                          (DateTimeHelper.from_rfc3339(hash['StartDateTime']) if hash['StartDateTime'])
                        else
                          SKIP
                        end
      apply_payment = hash.key?('ApplyPayment') ? hash['ApplyPayment'] : SKIP
      test = hash.key?('Test') ? hash['Test'] : SKIP

      # Create object from extracted values.
      UpdateAppointmentRequest.new(appointment_id,
                                   end_date_time,
                                   execute,
                                   gender_preference,
                                   notes,
                                   partner_external_id,
                                   provider_id,
                                   resource_ids,
                                   send_email,
                                   session_type_id,
                                   staff_id,
                                   start_date_time,
                                   apply_payment,
                                   test)
    end

    def to_custom_end_date_time
      DateTimeHelper.to_rfc3339(end_date_time)
    end

    def to_custom_start_date_time
      DateTimeHelper.to_rfc3339(start_date_time)
    end
  end
end
