# mindbody_public_api
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

require 'date'
module MindbodyPublicApi
  # PurchaseContractRequest Model.
  class PurchaseContractRequest < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # When `true`, the Public API validates input information, but does not
    # commit it, so no client data is affected.<br />
    # When `false` or omitted, the transaction is committed, and client data is
    # affected.<br />
    # Default: **false**
    # @return [TrueClass | FalseClass]
    attr_accessor :test

    # The ID of the location where the client is purchasing the contract; used
    # for AutoPays.
    # @return [Integer]
    attr_accessor :location_id

    # The ID of the client. Note that this is not the same as the client’s
    # unique ID.
    # @return [String]
    attr_accessor :client_id

    # The ID of the contract being purchased.
    # @return [Integer]
    attr_accessor :contract_id

    # The date that the contract starts.<br />
    # Default: **today’s date**
    # @return [DateTime]
    attr_accessor :start_date

    # The date on which the first payment is to occur. Possible values:
    # * Instant
    # * `StartDate`
    # @return [String]
    attr_accessor :first_payment_occurs

    # A representation of the client’s signature. This value can take the form
    # of Base64-encoded byte array. The file type should be PNG. The picture of
    # the client’s signature is uploaded and viewable from the Client Documents
    # page in the Core Business Mode software. The title of the document is:<br
    # />
    # clientContractSignature-{uniquePurchasedClientContractID}-{contractName}-{
    # contractStartDate}.{fileType}
    # @return [String]
    attr_accessor :client_signature

    # A promotion code, if one applies. Promotion codes are applied to items
    # that are both marked as pay now in a contract and are discounted by the
    # promotion code. If a pay now item is an autopay item, its autopay price is
    # the price at the time of checkout, so, if a promotion code was applied,
    # all autopays are scheduled using that discounted price.
    # @return [String]
    attr_accessor :promotion_code

    # Promotion codes, if they apply. Promotion codes are applied to items that
    # are both marked as pay now in a contract and are discounted by the
    # promotion code. If a pay now item is an autopay item, its autopay price is
    # the price at the time of checkout, so, if a promotion code was applied,
    # all autopays are scheduled using that discounted price.
    # @return [Array[String]]
    attr_accessor :promotion_codes

    # INformation about an individual credit card
    # @return [CreditCardInfo]
    attr_accessor :credit_card_info

    # INformation about an individual credit card
    # @return [StoredCardInfo]
    attr_accessor :stored_card_info

    # When `true`, indicates that email and SMS notifications should be sent to
    # the client after purchase.<br />
    # Default: **true**
    # @return [TrueClass | FalseClass]
    attr_accessor :send_notifications

    # The ID of the staff member to be marked as the sales rep for this contract
    # sale.
    # @return [Integer]
    attr_accessor :sales_rep_id

    # When `true`, indicates that the direct debit information stored on the
    # client's account is to be used to pay for the contract.<br />
    # This is only required if both `CreditCardInfo` and `StoredCardInfo` are
    # not passed.<br />
    # Default: **false**
    # @return [TrueClass | FalseClass]
    attr_accessor :use_direct_debit

    # When `true`, indicates that the consumer is present or otherwise able to
    # successfully negotiate an SCA challenge. It is not a good idea to have
    # this always be false as that could very likely lead to a bank declining
    # all transactions for the merchant.
    # Defaults to **false**.
    # @return [TrueClass | FalseClass]
    attr_accessor :consumer_present

    # The URL consumer is redirected to if the bank requests SCA. This field is
    # only needed if ConsumerPresent is true.
    # @return [String]
    attr_accessor :payment_authentication_callback_url

    # Optional, date to prorate contract
    # @return [DateTime]
    attr_accessor :prorate_date

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['test'] = 'Test'
      @_hash['location_id'] = 'LocationId'
      @_hash['client_id'] = 'ClientId'
      @_hash['contract_id'] = 'ContractId'
      @_hash['start_date'] = 'StartDate'
      @_hash['first_payment_occurs'] = 'FirstPaymentOccurs'
      @_hash['client_signature'] = 'ClientSignature'
      @_hash['promotion_code'] = 'PromotionCode'
      @_hash['promotion_codes'] = 'PromotionCodes'
      @_hash['credit_card_info'] = 'CreditCardInfo'
      @_hash['stored_card_info'] = 'StoredCardInfo'
      @_hash['send_notifications'] = 'SendNotifications'
      @_hash['sales_rep_id'] = 'SalesRepId'
      @_hash['use_direct_debit'] = 'UseDirectDebit'
      @_hash['consumer_present'] = 'ConsumerPresent'
      @_hash['payment_authentication_callback_url'] =
        'PaymentAuthenticationCallbackUrl'
      @_hash['prorate_date'] = 'ProrateDate'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        test
        location_id
        start_date
        first_payment_occurs
        client_signature
        promotion_code
        promotion_codes
        credit_card_info
        stored_card_info
        send_notifications
        sales_rep_id
        use_direct_debit
        consumer_present
        payment_authentication_callback_url
        prorate_date
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(client_id = nil, contract_id = nil, test = SKIP,
                   location_id = SKIP, start_date = SKIP,
                   first_payment_occurs = SKIP, client_signature = SKIP,
                   promotion_code = SKIP, promotion_codes = SKIP,
                   credit_card_info = SKIP, stored_card_info = SKIP,
                   send_notifications = SKIP, sales_rep_id = SKIP,
                   use_direct_debit = SKIP, consumer_present = SKIP,
                   payment_authentication_callback_url = SKIP,
                   prorate_date = SKIP)
      @test = test unless test == SKIP
      @location_id = location_id unless location_id == SKIP
      @client_id = client_id
      @contract_id = contract_id
      @start_date = start_date unless start_date == SKIP
      @first_payment_occurs = first_payment_occurs unless first_payment_occurs == SKIP
      @client_signature = client_signature unless client_signature == SKIP
      @promotion_code = promotion_code unless promotion_code == SKIP
      @promotion_codes = promotion_codes unless promotion_codes == SKIP
      @credit_card_info = credit_card_info unless credit_card_info == SKIP
      @stored_card_info = stored_card_info unless stored_card_info == SKIP
      @send_notifications = send_notifications unless send_notifications == SKIP
      @sales_rep_id = sales_rep_id unless sales_rep_id == SKIP
      @use_direct_debit = use_direct_debit unless use_direct_debit == SKIP
      @consumer_present = consumer_present unless consumer_present == SKIP
      unless payment_authentication_callback_url == SKIP
        @payment_authentication_callback_url =
          payment_authentication_callback_url
      end
      @prorate_date = prorate_date unless prorate_date == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      client_id = hash.key?('ClientId') ? hash['ClientId'] : nil
      contract_id = hash.key?('ContractId') ? hash['ContractId'] : nil
      test = hash.key?('Test') ? hash['Test'] : SKIP
      location_id = hash.key?('LocationId') ? hash['LocationId'] : SKIP
      start_date = if hash.key?('StartDate')
                     (DateTimeHelper.from_rfc3339(hash['StartDate']) if hash['StartDate'])
                   else
                     SKIP
                   end
      first_payment_occurs =
        hash.key?('FirstPaymentOccurs') ? hash['FirstPaymentOccurs'] : SKIP
      client_signature =
        hash.key?('ClientSignature') ? hash['ClientSignature'] : SKIP
      promotion_code = hash.key?('PromotionCode') ? hash['PromotionCode'] : SKIP
      promotion_codes =
        hash.key?('PromotionCodes') ? hash['PromotionCodes'] : SKIP
      credit_card_info = CreditCardInfo.from_hash(hash['CreditCardInfo']) if
        hash['CreditCardInfo']
      stored_card_info = StoredCardInfo.from_hash(hash['StoredCardInfo']) if
        hash['StoredCardInfo']
      send_notifications =
        hash.key?('SendNotifications') ? hash['SendNotifications'] : SKIP
      sales_rep_id = hash.key?('SalesRepId') ? hash['SalesRepId'] : SKIP
      use_direct_debit =
        hash.key?('UseDirectDebit') ? hash['UseDirectDebit'] : SKIP
      consumer_present =
        hash.key?('ConsumerPresent') ? hash['ConsumerPresent'] : SKIP
      payment_authentication_callback_url =
        hash.key?('PaymentAuthenticationCallbackUrl') ? hash['PaymentAuthenticationCallbackUrl'] : SKIP
      prorate_date = if hash.key?('ProrateDate')
                       (DateTimeHelper.from_rfc3339(hash['ProrateDate']) if hash['ProrateDate'])
                     else
                       SKIP
                     end

      # Create object from extracted values.
      PurchaseContractRequest.new(client_id,
                                  contract_id,
                                  test,
                                  location_id,
                                  start_date,
                                  first_payment_occurs,
                                  client_signature,
                                  promotion_code,
                                  promotion_codes,
                                  credit_card_info,
                                  stored_card_info,
                                  send_notifications,
                                  sales_rep_id,
                                  use_direct_debit,
                                  consumer_present,
                                  payment_authentication_callback_url,
                                  prorate_date)
    end

    def to_custom_start_date
      DateTimeHelper.to_rfc3339(start_date)
    end

    def to_custom_prorate_date
      DateTimeHelper.to_rfc3339(prorate_date)
    end
  end
end
